# -*- coding: utf-8 -*-
"""Aula02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16mWw2B-kUllQgOb5eMqz2_RTtaXFQD-H

##**Aula 02: PID e Segmentação por PIXEL**

###Imports
"""

# Imports
import cv2
import numpy as np
from matplotlib import pyplot as plt

# Nova biblioteca
import math # Biblioteca de matemática

"""### Desenhando Letras com Arrays de Pixels

#### Desafio 05: Primeira letra do nome (Ana Luísa)
"""

imgAL = np.zeros((4, 7), dtype=np.uint8)

# Letra A
imgAL [0,0] = 255
imgAL [1,0] = 255
imgAL [2,0] = 255
imgAL [3,0] = 255
imgAL [0,1] = 255
imgAL [0,2] = 255
imgAL [1,2] = 255
imgAL [2,2] = 255
imgAL [3,2] = 255
imgAL [2,1] = 255

# Letra L
imgAL [0,4] = 255
imgAL [1,4] = 255
imgAL [2,4] = 255
imgAL [3,4] = 255
imgAL [3,5] = 255
imgAL [3,6] = 255

plt.imshow(imgAL, cmap="grey")

"""##### Deixando colorido"""

imgAL = np.zeros((4, 7, 3), dtype=np.uint8)

# Letra A
imgAL [0,0] = 137, 204, 4
imgAL [1,0] = 137, 204, 4
imgAL [2,0] = 137, 204, 4
imgAL [3,0] = 137, 204, 4
imgAL [0,1] = 137, 204, 4
imgAL [0,2] = 137, 204, 4
imgAL [1,2] = 137, 204, 4
imgAL [2,2] = 137, 204, 4
imgAL [3,2] = 137, 204, 4
imgAL [2,1] = 137, 204, 4

# Letra L
imgAL [0,4] = 137, 204, 4
imgAL [1,4] = 137, 204, 4
imgAL [2,4] = 137, 204, 4
imgAL [3,4] = 137, 204, 4
imgAL [3,5] = 137, 204, 4
imgAL [3,6] = 137, 204, 4

plt.imshow(imgAL, cmap="grey")

"""#### Desafio 05: Primeira letra do nome (Victor Mori)

"""

img = np.zeros((3, 3), dtype=np.uint8)

img [0,0] = 255
img[0,2] = 255
img[1,0] = 255
img[1,2] = 255
img [2,1] = 255
plt.imshow(img, cmap="grey")

"""##### Deixando colorido"""

img = np.zeros((3, 3, 3), dtype=np.uint8)

img [0,0] = 137, 204, 4
img[0,2] = 137, 204, 4
img[1,0] = 137, 204, 4
img[1,2] = 137, 204, 4
img [2,1] = 137, 204, 4
plt.imshow(img)

"""###Split das Bandas RGB"""

img_RGB = cv2.imread("Folha.jpg")
img_RGB = cv2.cvtColor(img_RGB, cv2.COLOR_BGR2RGB)
plt.imshow(img_RGB)

R, G, B = cv2.split(img_RGB)
plt.imshow(R, cmap = "gray")
plt.show()
plt.imshow(G, cmap = "gray")
plt.show()
plt.imshow(B, cmap = "gray")
plt.show()

num_lin = img_RGB.shape[0]
num_col = img_RGB.shape[1]

img_gray =  np.zeros((num_lin, num_col), dtype=np.uint8)
for a in range (num_lin):
  for c in range (num_col):
    (r, g, b) = img_RGB[a, c]
    img_gray [a, c] = (int(r) + int(g) + int(b))/3
  plt.imshow(img_gray, cmap="gray")

img_gray = cv2.cvtColor(img_RGB, cv2.COLOR_RGB2GRAY)
plt.imshow(img_gray, cmap = "gray")

plt.imshow(img_RGB, cmap="Greens")
plt.colorbar()

"""### Desafio 06: Mapeamento de Cores"""

# Carregar a imagem:
img_sat = cv2.imread("satelite.jpg")

# Conversão: BGR 2 RGB:
img_sat = cv2.cvtColor(img_sat, cv2.COLOR_BGR2RGB)

# Converter a imagem para tons de cinza:
img_gray = cv2.cvtColor(img_sat, cv2.COLOR_RGB2GRAY)

# Aplicar a colormap
plt.imshow(img_gray, cmap="jet")

# Adicionar a barra de cores para representar os valores
plt.colorbar()

# Exibir a imagem
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Carregar a imagem em escala de cinza
img_gray = cv2.imread("Capture.png", cv2.IMREAD_GRAYSCALE)

# Verificar se a imagem foi carregada corretamente
if img_gray is None:
    print("Erro: a imagem não foi carregada. Verifique o caminho do arquivo!")
else:
    # Definir o limiar manual
    thresh = 23

    # Aplicar a função de limiarização usando o limiar definido
    img_bin = cv2.threshold(img_gray, thresh, 255, cv2.THRESH_BINARY)[1]

    # Exibir a imagem binarizada
    plt.imshow(img_bin, cmap='gray')
    plt.colorbar()
    plt.show()

    # Exibir o menor valor da imagem original
    print("Mínimo valor da imagem original:", img_gray.min())

"""### Desafio 07: Binarização de Imagem com Limiar no Canal Vermelho


"""

# Ler a imagem:
img_cor = cv2.imread("Flor.jpg")

# Split das bandas:
B, G, R = cv2.split(img_cor)

# Converter a imagem para escala de cinza (grayscale):
img_cinza = cv2.cvtColor(img_cor, cv2.COLOR_RGB2GRAY)

# Definir o limiar para binarização:
# Pixels maiores que 20 serão convertidos para 255, os menores para 0.
tresh = 20

# Aplicar a limiarização apenas no canal R -> Vermelho:
img_bin = cv2.threshold(R, tresh, 255, cv2.THRESH_BINARY)[1]

# Exibir a imagem original:
plt.imshow(img_cor)
plt.title("Imagem Original")
plt.show()

# Exibir a imagem binarizada:
plt.imshow(img_bin, cmap='gray')
plt.title("Imagem Binarizada (Limiar = 20)")
plt.show()

"""### Transformação Negativa"""

# Carregar a imagem em formato BGR:
img = cv2.imread('Flor.jpg')

# Converter para escala de cinza
e=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Converter o intervalo de níveis de cinzas de img para [0,1]
s = e.max() - e # Cada pixel passa de I para (255 - I)

# Exibir a imagem original em tons de cinza:
plt.imshow(e, cmap='gray')
plt.title("Imagem em Escala de Cinza")
plt.axis("off")
plt.show()

# Exibir a imagem negativa
plt.imshow(s, cmap='gray')
plt.title("Imagem Negativa")
plt.axis("off")
plt.show()

"""### Desafio 08: Filtro Negativo em imagem cinza"""

# Carregar a imagem
img_cogs = cv2.imread("cogumelo.png")

# Converter para escala de cinza
img_cogs_grey = cv2.cvtColor(img_cogs, cv2.COLOR_BGR2GRAY)

# Aplicar o filtro negativo (inversão de pixel = 255 - valor do pixel):
img_cogs_inv = 255 - img_cogs_grey

# Exibir a imagem original em tons de cinza
plt.imshow(img_cogs_grey, cmap="gray", interpolation="none")
plt.title("Imagem em Escala de Cinza")
plt.axis("off")
plt.show()

# Exibir a imagem invertida, negativa:
plt.imshow(img_cogs_inv, cmap="gray", interpolation="none")
plt.title("Imagem Negativa (Invertida)")
plt.axis("off")
plt.show()

"""### Desafio 09: Filtro negativo em imagem colorida"""

# Carregar a imagem:
img_drone = cv2.imread("drone.jpg")

# Converter para RGB:
img_drone_rgb = cv2.cvtColor(img_drone, cv2.COLOR_BGR2RGB)

# Aplicar filtro negativo:
img_drone_inv = 255 - img_drone_rgb

# Exibir a imagem original
plt.imshow(img_drone_rgb)
plt.title('Imagem Original')
plt.axis('off')
plt.show()

# Exibir a imagem negativa (cores invertidas)
plt.imshow(img_drone_inv)  # Mesma lógica da imagem original
plt.title('Imagem Invertida (Negativa)')
plt.axis('off')
plt.show()

"""### Desafio 10: Reconstrução de Imagem a partir de Quadrantes"""

# Carregar a imagem:
img_goku = cv2.imread('gokuinvertido.jpg')

# Converter para RGB:
img_goku_rgb = cv2.cvtColor(img_goku, cv2.COLOR_BGR2RGB)


# Obtendo dimensões da imagem:
altura = img_goku_rgb.shape[0]
largura = img_goku_rgb.shape[1]
print("Dimensões da imagem:")
print("Altura -> {}, Largura: -> {}".format(altura, largura))
print("")

# Definir metades da altura e largura para dividir a imagem em 4 quadrantes
alt2 = img_goku_rgb.shape[0] // 2  # Metade da altura
lar2 = img_goku_rgb.shape[1] // 2  # Metade da largura

# ------------ Criar os recortes dos 4 quadrantes, onde:

# crop1 = Superior esquerdo
crop1 = img_goku_rgb[0:alt2, 0:lar2]

# crop2 = Superior direito
crop2 = img_goku_rgb[0:alt2, lar2:]

# crop3 = Inferior esquerdo
crop3 = img_goku_rgb[alt2:, 0:lar2] # Inferior esquerdo

# crop4 = Inferior direito
crop4 = img_goku_rgb[alt2:, lar2:] # Inferior direito

#Criar uma cópia da imagem para reorganizar os quadrantes
img_corrigida = img_goku_rgb.copy()

# ------------ Reorganizar os quadrantes na ordem correta:

# Superior esquerdo recebe Inferior direito
img_corrigida[0:alt2, 0:lar2] = crop4

# Superior direito recebe Inferior esquerdo
img_corrigida[0:alt2, lar2:largura] = crop3

# Inferior esquerdo recebe Superior direito
img_corrigida[alt2:altura, 0:lar2] = crop2

# Inferior direito recebe Superior esquerdo
img_corrigida[alt2:altura, lar2:largura] = crop1

# Exibin imagem original:
plt.imshow(img_goku_rgb)
plt.title('Imagem Original')
plt.axis('off')
plt.show()

print("")

# Exibir imagem reorganizada:
plt.imshow(img_corrigida)
plt.title("Imagem Reorganizada")
plt.axis("off")
plt.show()

"""### Desafio 11: Segmentação de Imagem por Manipulação de Pixels"""

# Carregar a imagem
imagem = cv2.imread("drone.jpg")

# Converter de BGR para RGB
image = cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB)

# Percorrer a imagem pixel por pixel e modificar os valores
for y in range(0, image.shape[0]):
    for x in range(0, image.shape[1]):
        if image[y, x, 0] > 40:
            image[y, x] = (255, 255, 255)

# Exibir a imagem segmentada
plt.imshow(image, interpolation="none")
plt.title("Imagem Segmentada")
plt.axis("off")
plt.show()