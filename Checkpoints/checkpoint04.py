# -*- coding: utf-8 -*-
"""Checkpoint04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19OdOenUDNz_Z8ZWp1OO6mEgzm5Ao4ky0

# Checkpoint 04 - 25/08/2025
"""

# Commented out IPython magic to ensure Python compatibility.
# Imports
# %matplotlib inline
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

"""## Parte 01"""

# Carregar dataset
df = pd.read_csv('WineQT.csv')

# Definir nomes de colunas
header = [
    'acidez_fixa',
    'acidez_volatil',
    'acido_citrico',
    'acucar_residual',
    'cloretos',
    'livre_de_dioxido_de_enxofre',
    'total_de_dioxido_de_enxofre',
    'densidade',
    'ph',
    'sulfatos',
    'alcool',
    'qualidade',
    'id'
]

df.columns = header

# Carregar com novos nomes
df = pd.read_csv('WineQT.csv', skiprows=1, header=None, names=header)


# Carregar 05 primeiras linhas
df.head()

# Estatísticas descritivas
df.describe()

# Valores ausentes ou inconsistências
df.info();

# Análises gráficas
# Correlação entre atributos
cols = df.columns
corr_matx = df[cols].corr()

heatmap = sns.heatmap(corr_matx, cbar=True, annot=True, square=True, fmt='.2f', annot_kws={'size':6}, yticklabels=cols, xticklabels= corr_matx)

## Ao analisar a relação entre as propriedades da base de dados, temos que buscar por correlações que cheguem próximo ao 1 (exceto as que são 1, pois são relação entre a mesma propriedade)

## Variaveis que tem boas relações:
## 1 - acido_citrico com a acidez_fixa
## 2 - densidade com a acidez_fixa
## 3 - qualidade do vinho com a quantidade de alcool
## 4 - qualidade com acido_citrico
## 5 - qualidade com sulfatos

#grafico 2
#box and whisker plots
df.plot(
  kind='box',
  subplots=True,
  layout=(5,3),
  sharex=False,
  figsize=(16,16)
)
plt.show()

## Para analisar o grafico box and whisker plots temos que  analisar se os dados tem uma dispersão dos dados entre eles, criando a possibilidade de diferenciar os tipos de vinho através desses dados.
## o acido_citrico apresenta uma diferença significativa entre os dados e  poucos casos de anomalias podendo ser um diferencial significativo entre os tipos de vinhos
## o alcool  também é um bom canditado para alimentar o modelo, pois possui uma boa separação entre os dados e poucas anomalias
## outras variaveis apresentam uma boa dispersão como, acidez_volatil, sulfatos,acidez_fixa, densidade e ph porem tem muitas anomalias, podendo causar conflitos no modelo embora se relacionados possam ter um resultado melhor

## grafico 3
## histograma

df.drop(columns=['id']).hist(
    bins=100,
    figsize=(10,10)
)
plt.show()
## Com o histograma conseguimos ver a quantidade de repetição de cada atributo e podemos relacionar as propriedades com base na sua repetição (exemplo não relacionado aos dados: se a acidez_fixa repete 50% e os vinhos 8 são 50% existem boas chances de um um vinho bom ser ácido)
## no alcool temos dados bem separados e que e que se repetem bastante sendo um bom indicador da qualidade dos dados
## embora não tão separado quanto o alcool a acidez_volatil apresenta uma boa separação e boa repetição podendo ser um bom indicador da qualdiade
## a acidez_fixa apresenta caracteristicas semelhantes a da acidez_volatil, podendo ser um bom indicador quando relacionado a outros dados

##pairplot
sns.pairplot(
    df,
    hue='qualidade',
    height=1.5
)
## para fazer a analise desse grafico precisamos buscar as melhores opções (os que tão mais em diagonal), pois significa que eles tem mais relação
## propriedades que tem mais relação e melhor qualidade
## acidez_fixa -> densidade
## ph -> alcool
## acido_critico -> acidez_fixa

"""## Parte 02"""

# Função para classificar vinhos
def classificar_vinho(valor):
    if valor >= 0 and valor <= 3:
        return "vinho péssimo"
    elif valor >= 4 and valor < 8:
        return "vinho médio"
    else:
        return "vinho excelente"

# Criar a nova coluna
df["qualidade_rotulo"] = df["qualidade"].apply(classificar_vinho)

# Conferir as primeiras linhas
print(df[["qualidade", "qualidade_rotulo"]].head(10))

"""## Parte 03"""

## variaveis importantes:
## 1 - acidez_fixa
## 2 - alcool
## 3 - acido_critico
## 4 - densidade


## essas variaveis são importantes pois vimos nos graficos que elas possuem uma grande relação e disperão entre os dados podendo ser diferenciados com base na qualidade do vinho e outros fatores. Sendo fortes fatores para treinar o modelo

sub_df = df[
    [
      'densidade',
      'acidez_fixa',
      'alcool',
      'acido_citrico',
      'sulfatos'
    ]
  ]

"""## Parte 04"""

from sklearn.model_selection import train_test_split
from sklearn.model_selection import StratifiedKFold, cross_val_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

classe = df['qualidade']
entrada_treino, entrada_teste, classes_treino, classes_teste = train_test_split(
    sub_df,
    classe,
    test_size=0.2,
    stratify=classe
)

print(f"formato das tabelas de treino {entrada_treino.shape} e teste {classes_teste.shape}")

"""## Parte 05"""

#Gera uma lista com valores de 1 a 20 para ver o melhor K
valores_k = list(range(1, 20))
medias = []

#Calcula o melhor valor de K
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

for k_tmp in valores_k:
    modelo_tmp = KNeighborsClassifier(n_neighbors=k_tmp)
    scores = cross_val_score(modelo_tmp, entrada_treino, classes_treino, cv=cv, scoring='accuracy')
    medias.append(scores.mean())

best_k = valores_k[int(np.argmax(medias))]
print("Melhor K:", best_k)

#Printa o gráfico vendo a acuracia de cada K
plt.figure(figsize=(6,4))
plt.plot(valores_k, medias, marker='o')
plt.title("Acurácia média (CV) por K")
plt.xlabel("K")
plt.ylabel("Acurácia média (cv)")
plt.grid(True)
plt.show()

try:
    k = int(best_k)
except NameError:
    k = 19

modelo = KNeighborsClassifier(n_neighbors=k)

modelo.fit(entrada_treino, classes_treino)
print("Modelo treinado com K =", k)

classes_encontradas = modelo.predict(entrada_teste)
print("Predição: {}".format(classes_encontradas))

acertos = accuracy_score(classes_teste, classes_encontradas)
print("Acerto médio de classificação: ", acertos)

## após analisar combinações, percebemos que a melhore relação dos dados para encontrar a qualidade são:
##     'densidade'
##     'acidez_fixa'
##     'alcool'
##     'acido_citrico'
##     'sulfatos'
## com outras combinações de dados com cloretos e os dioxidos de enxofre acabaram diminuindo a acuracia do modelo, pois não possuima uma relação certeira

